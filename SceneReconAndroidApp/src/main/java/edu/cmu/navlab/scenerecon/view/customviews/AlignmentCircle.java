package edu.cmu.navlab.scenerecon.view.customviews;import android.content.Context;import android.content.SharedPreferences;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.RectF;import android.preference.PreferenceManager;import edu.cmu.navlab.scenerecon.R;/** * An AlignmentCircle is an object drawn on the screen to indicate the angle a * user is around the z and y earth axes. See research log for axes definition. */public class AlignmentCircle {    // The width of the canvas in degrees    private float mCanvasWidthInDegrees;    // The degrees length between two AlignmentCircles    private float mDegreeSeparation;    // The yaw represented by this AlignmentCircle    private float mYaw;    // The roll represented by this AlignmentCircle    private float mRoll;    // The paint used to color the AlignmentCircle    private Paint mPaint;    // The radius of the AlignmentCircle    private float mRadius;    // Indicates whether a picture has been taken with this AlignmentCircle    private boolean pictureTaken = false;    // Icon placed on circle if a picture has been taken at the AlignmentCircle    private Bitmap cameraIcon;    // Indicates whether this AlignmentCircle is in margins    private boolean mLeftMargin;    private boolean mTopMargin;    private boolean mRightMargin;    private boolean mBottomMargin;    private boolean debug = false;    public AlignmentCircle(Bitmap cameraIcon, float degreeSeparation, float yaw, float roll,                           Paint paint, float radius, boolean leftMargin, boolean topMargin,                           boolean rightMargin, boolean bottomMargin, Context context)    {        mDegreeSeparation = degreeSeparation;        mYaw = yaw;        mRoll = roll;        mPaint = paint;        mRadius = radius;        this.cameraIcon = cameraIcon;        mLeftMargin = leftMargin;        mTopMargin = topMargin;        mRightMargin = rightMargin;        mBottomMargin = bottomMargin;        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);        mCanvasWidthInDegrees = Float.parseFloat(prefs.getString("canvas_width_degrees",                context.getString(R.string.canvas_width_degrees_default)));    }    /**     * Method used to draw the AlignmentCircle on a canvas     */    public void drawSelf(Canvas canvas, float yaw, float roll) {        // Don't draw the circle on the canvas if it won't be seen        if (!isOnScreen(yaw, roll, canvas)) {            return;        }        if (yaw < 0) {            yaw += 360;        }        if (roll < 0) {            roll += 360;        }        float offsetFromCenterCanvasY = mRoll - roll; // in degrees        offsetFromCenterCanvasY = getCanvasHeightFromDegrees(offsetFromCenterCanvasY, canvas); // in pixels        float cy = (canvas.getHeight() / 2) + offsetFromCenterCanvasY;        float offsetFromCenterCanvasX = yaw - mYaw; // in degrees        offsetFromCenterCanvasX = getCanvasLengthFromDegrees(offsetFromCenterCanvasX, canvas); // in pixels        float cx = canvas.getWidth() / 2 + offsetFromCenterCanvasX;        canvas.drawCircle(cx, cy, mRadius, mPaint);        float horizontalLineLength =                getCanvasLengthFromDegrees(mDegreeSeparation, canvas) - 2 * mRadius;        float verticalLineLength =                getCanvasHeightFromDegrees(mDegreeSeparation, canvas) - 2 * mRadius;        if (!mLeftMargin) {            // Draw left line            float leftStartX = cx - mRadius - horizontalLineLength;            float leftStopX = leftStartX + horizontalLineLength;            canvas.drawLine(leftStartX, cy, leftStopX, cy, mPaint);        }        if (!mRightMargin) {            // Draw right line            float rightStartX = cx + mRadius;            float rightStopX = rightStartX + horizontalLineLength;            canvas.drawLine(rightStartX, cy, rightStopX, cy, mPaint);        }        if (!mBottomMargin) {            // Draw bottom line            float bottomStartY = cy + mRadius;            float bottomStopY = bottomStartY + verticalLineLength;            canvas.drawLine(cx, bottomStartY, cx, bottomStopY, mPaint);        }        if (!mTopMargin) {            // Draw top line            float topStartY = cy - mRadius - verticalLineLength;            float topStopY = topStartY + verticalLineLength;            canvas.drawLine(cx, topStartY, cx, topStopY, mPaint);        }        if (pictureTaken) {            RectF rectf = new RectF();            rectf.bottom = (float) (cy + mRadius * Math.sin(Math.toRadians(45)));            rectf.top = (float) (cy - mRadius * Math.sin(Math.toRadians(45)));            rectf.left = (float) (cx - mRadius * Math.cos(Math.toRadians(45)));            rectf.right = (float) (cx + mRadius * Math.cos(Math.toRadians(45)));            canvas.drawBitmap(cameraIcon, null, rectf, mPaint);        }        if (debug) {            mPaint.setTextSize(45);            canvas.drawText(String.valueOf(mRoll), cx - 3 * mRadius / 4, cy + mRadius / 5, mPaint);        }    }    // Used to indicate that a picture has been taken on this AlignmentCircle    public void pictureTaken() {        pictureTaken = true;    }    public boolean isPictureTaken() {        return pictureTaken;    }    /**     * Returns the width of the canvas in degrees     */    private float getCanvasWidthInDegrees() {        return mCanvasWidthInDegrees;    }    /**     * Returns the height of the canvas in degrees     */    private float getCanvasHeightInDegrees(Canvas canvas) {        return ((float)canvas.getHeight() / (float) canvas.getWidth()) * getCanvasWidthInDegrees();    }    /**     * Returns the length of the canvas covered by the degrees given     */    private float getCanvasLengthFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getWidth() / getCanvasWidthInDegrees());    }    /**     * Returns the height of the canvas covered by the degrees given     */    private float getCanvasHeightFromDegrees(float degrees, Canvas canvas) {        return degrees * (canvas.getHeight() / getCanvasHeightInDegrees(canvas));    }    /**     * Returns the amount of degrees represented by a length of canvas     */    private float getDegreesFromCanvasWidth(float length, Canvas canvas) {        return length * (canvas.getWidth() / 360);    }    /**     * Returns the amount of degrees represented by a portion of the height of     * the canvas     */    private float getDegreesFromCanvasHeight(float length, Canvas canvas) {        return length * (canvas.getHeight() / 360);    }    public float getRoll() {        return mRoll;    }    public float getYaw() {        return mYaw;    }    /**     * Returns whether or not the AlignmentCircle is viewable on the canvas     * based on the direction the user is currently facing.     */    private boolean isOnScreen(float yaw, float roll, Canvas canvas) {        if (yaw < 0) {            yaw += 360;        }        float yawDegrees = getDegreesFromCanvasWidth(mRadius, canvas);        double upperBoundYaw = yaw + (getCanvasWidthInDegrees() / 2) + yawDegrees;        double lowerBoundYaw = yaw - (getCanvasWidthInDegrees() / 2) - yawDegrees;        double rollDegrees = getDegreesFromCanvasHeight(mRadius, canvas);        double upperBoundRoll = roll + (getCanvasHeightInDegrees(canvas) / 2) + rollDegrees;        double lowerBoundRoll = roll - (getCanvasHeightInDegrees(canvas) / 2) - rollDegrees;        return (mYaw > lowerBoundYaw && mYaw < upperBoundYaw)                && (mRoll > lowerBoundRoll && mRoll < upperBoundRoll);    }}