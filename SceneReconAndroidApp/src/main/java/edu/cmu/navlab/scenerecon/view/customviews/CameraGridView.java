package edu.cmu.navlab.scenerecon.view.customviews;import android.content.Context;import android.content.SharedPreferences;import android.content.res.Resources;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Paint;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.preference.PreferenceManager;import android.speech.tts.TextToSpeech;import android.util.AttributeSet;import android.util.DisplayMetrics;import android.util.Log;import android.util.TypedValue;import android.view.View;import android.widget.TextView;import java.text.DecimalFormat;import java.util.Locale;import edu.cmu.navlab.scenerecon.R;/** * HorizontalOffSetView is a custom view used to indicate if the device is * horizontal with respect to the ground. It draws all of the AlignmentCircles * and the cross-hairs and draws itself based on the sensor data it receives. */public class CameraGridView extends View implements SensorEventListener {    private static final String TAG = "HorizontalOffsetView";    private static final int STATS_X_DP = 20;    private static final int STATS_WIDTH_DP = 100;    private static final int ROLL_Y_DP = 40;    private static final int PITCH_Y_DP = 25;    private static final int YAW_Y_DP = 25;    private static final int CCOUNT_L1_Y_DP = 25;    private static final int CCOUNT_L2_Y_DP = 5;    private int mCirclesCount;    private float mCirclesDegreeSep;    private float[] mFilter;    private int baseLineColor;    private int unalignedIndicatorColor;    private int alignedIndicatorColor;    private int uniquePicturesTaken = 0;    private double horizontalOffset = 0;    private double zDeviceGravity = 0;    private float mHorizonOffset;    private float angleOffNorth = 0f;    private float mStrokeWidth;    private float mCircleRadius;    private float[] mGravityOrientation = new float[3];    private float[] mGeomagneticOrientation = new float[3];    private long sysTime = 0;    private boolean isAligned;    private Paint mBaseLinePaint;    private Paint mUnalignedPaint;    private Paint mAlignedPaint;    private Paint mIndicatorPaint;    private Paint mTextBackgroundPaint;    private Paint mTextPaint;    private EventListener mEventListener;    private SensorManager mSensorManager;    private Sensor mGravitySensor;    private Sensor mMagneticFieldSensor;    private Sensor mAccelerometer;    private Sensor mRotationVector;    private AlignmentCircle[][] mAlignmentCircles;    private Context mContext;    private boolean mCirclesVisible;    private TextToSpeech mTextToSpeech;    private boolean mUserWelcomed;    private TextView mInstView;    private int mRevolutions;    private boolean mFirstAngleOffNorthReading;    public CameraGridView(Context context, AttributeSet attrs) {        super(context, attrs);        mContext = context;        TypedArray typedArray = context.getTheme().obtainStyledAttributes(                attrs, R.styleable.CameraGridView, 0, 0);        try {            baseLineColor = typedArray.getColor(R.styleable.CameraGridView_base_line_color, 0);            unalignedIndicatorColor =                    typedArray.getColor(R.styleable.CameraGridView_indicator_color_unaligned, 0);            alignedIndicatorColor =                    typedArray.getColor(R.styleable.CameraGridView_indicator_color_aligned, 0);        } finally {            typedArray.recycle();        }        mCirclesVisible = false;        mRevolutions = 0;        mFirstAngleOffNorthReading = true;        mUserWelcomed = false;        initConstants();        initSensors();        initPaints();    }    @Override    public void onAttachedToWindow() {        super.onAttachedToWindow();        View p = (View) getParent();        mInstView = (TextView) p.findViewById(R.id.scene_recon_instruction_view);        initTTS();    }    public int dipToPixels(int dip) {        Resources r = getResources();        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, (float) dip,                r.getDisplayMetrics());    }    public int spToPixels(int sp) {        DisplayMetrics metrics = getResources().getDisplayMetrics();        return (int) (metrics.scaledDensity * dipToPixels(sp));    }    /**     * Draws the baselines that the indicator line (cross-hairs) is to align     * with.     */    private void drawBase(Canvas canvas) {        for (AlignmentCircle[] yaw : mAlignmentCircles) {            for (AlignmentCircle alignmentCircle : yaw) {                alignmentCircle.drawSelf(canvas, angleOffNorth, mHorizonOffset);            }        }    }    /**     * Draws the center circle for the cross-hairs.     */    private void drawIndicatorCircle(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Draw the circle in the base line        mIndicatorPaint = isAligned ? mAlignedPaint : mUnalignedPaint;        canvas.drawCircle(centerX, centerY, mCircleRadius, mIndicatorPaint);    }    /**     * Draws the horizontal and vertical cross-hair lines.     */    private void drawIndicatorLine(Canvas canvas) {        float centerX = ((float) canvas.getWidth()) / 2;        float centerY = ((float) canvas.getHeight()) / 2;        // Lines are drawn from left to right and top to bottom        float startX_left = 0f;        float startY_left = (float) (centerY - centerX * Math.tan(Math.toRadians(horizontalOffset)));        float stopX_left = centerX - (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float stopY_left = centerY - (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        float startX_right = centerX + (float) (mCircleRadius * Math.cos(Math.toRadians(horizontalOffset)));        float startY_right = centerY + (float) (mCircleRadius * Math.sin(Math.toRadians(horizontalOffset)));        float stopX_right = (float) canvas.getWidth();        float stopY_right = (float) (centerY + centerX * Math.tan(Math.toRadians(horizontalOffset)));        float startX_top = (float) (centerX - (canvas.getHeight() / 2) * Math.tan(Math.toRadians(360 - horizontalOffset)));        float startY_top = 0f;        float stopX_top = (float) (centerX - mCircleRadius * Math.sin(Math.toRadians(360 - horizontalOffset)));        float stopY_top = (float) (centerY - mCircleRadius * Math.cos(Math.toRadians(360 - horizontalOffset)));        float startX_bottom = (float) (centerX + mCircleRadius * Math.sin(Math.toRadians(360 - horizontalOffset)));        float startY_bottom = (float) (centerY + mCircleRadius * Math.cos(Math.toRadians(360 - horizontalOffset)));        float stopX_bottom = (float) (centerX + (canvas.getHeight() / 2) * Math.tan(Math.toRadians(360 - horizontalOffset)));        float stopY_bottom = canvas.getHeight();        canvas.drawLine(startX_left, startY_left, stopX_left, stopY_left, mIndicatorPaint);        canvas.drawLine(startX_right, startY_right, stopX_right, stopY_right, mIndicatorPaint);        canvas.drawLine(startX_top, startY_top, stopX_top, stopY_top, mIndicatorPaint);        canvas.drawLine(startX_bottom, startY_bottom, stopX_bottom, stopY_bottom, mIndicatorPaint);    }    /**     * Draws the cross-hairs.     */    private void drawIndicator(Canvas canvas) {        drawIndicatorCircle(canvas);        drawIndicatorLine(canvas);    }    // Draws roll, pitch, yaw, and x-y-z displacement    private void drawStats(Canvas canvas) {        int statsWidthPX = dipToPixels(STATS_WIDTH_DP);        canvas.drawRect(0, 0, statsWidthPX, canvas.getHeight(), mTextBackgroundPaint);        int statXPX = dipToPixels(STATS_X_DP);        int rollYPX = dipToPixels(ROLL_Y_DP);        DecimalFormat decimalFormat = new DecimalFormat("###.###");        canvas.drawText("Roll: " + Double.valueOf(decimalFormat.format(mHorizonOffset)),                statXPX, rollYPX, mTextPaint);        int pitchYPX = rollYPX + spToPixels(PITCH_Y_DP);        canvas.drawText("Pitch: " + Double.valueOf(decimalFormat.format(horizontalOffset)),                statXPX, pitchYPX, mTextPaint);        int yawYPX = pitchYPX + spToPixels(YAW_Y_DP);        canvas.drawText("Yaw: " + Double.valueOf(decimalFormat.format(angleOffNorth)),                statXPX, yawYPX, mTextPaint);        int picsHeaderYPX = yawYPX + spToPixels(CCOUNT_L1_Y_DP);        canvas.drawText("Circles covered: ", statXPX, picsHeaderYPX, mTextPaint);        int picsStatYPX = picsHeaderYPX + spToPixels(CCOUNT_L2_Y_DP);        String pictureCount = Integer.toString(uniquePicturesTaken) + "/"                + Integer.toString(mCirclesCount * mCirclesCount);        canvas.drawText(pictureCount, statXPX, picsStatYPX, mTextPaint);        if (uniquePicturesTaken >= mCirclesCount * mCirclesCount) {            mCirclesVisible = false;            uniquePicturesTaken = 0;            instructMove();        }    }    /**     * Call this method after taking a picture. It returns a string detailing     * the device rotation that is used for naming the image.     */    public String getCurrentRotations() {        return "_Roll_" + Float.toString(mHorizonOffset) + "_Pitch_" + Float.toString(angleOffNorth);    }    public void onPictureTaken() {        if (!mCirclesVisible) {            initAlignmentCircles(angleOffNorth, mHorizonOffset);            instructCoverCircles(mCirclesCount * mCirclesCount - uniquePicturesTaken - 1);            mCirclesVisible = true;        }        // Look for the circle that got its picture taken and tell it that its        // picture was taken        for (AlignmentCircle[] yaw : mAlignmentCircles) {            for (AlignmentCircle circle : yaw) {                // Threshold used for determining if a particular circle had its                // picture taken                int delta = 2;                if (Math.abs(circle.getRoll() - mHorizonOffset) < delta || Math.abs(circle.getRoll() - mHorizonOffset + 360) < delta) {                    if (Math.abs(circle.getYaw() - angleOffNorth) < delta || Math.abs(circle.getYaw() - angleOffNorth + 360) < delta) {                        if (!circle.isPictureTaken()) {                            uniquePicturesTaken++;                        }                        circle.pictureTaken();                    }                }            }        }    }    private void initTTS() {        mTextToSpeech = new TextToSpeech(getContext().getApplicationContext(),                new TextToSpeech.OnInitListener() {                    @Override                    public void onInit(int status) {                        if(status != TextToSpeech.ERROR){                            mTextToSpeech.setLanguage(Locale.US);                        }                        if (!mUserWelcomed) {                            welcomeUser();                            mUserWelcomed = true;                        }                    }                });    }    /**     * Instantiate AlignmentCircles in the beginning to avoid repeated object     * creation in onDraw()     */    public void initAlignmentCircles(float centerYaw, float centerRoll) {        int margin = (int) Math.ceil((float) mCirclesCount / 2f) - 1;        // Note that leftYaw is greater than rightYaw        float rightYaw = centerYaw + mCirclesDegreeSep * -margin;        float leftYaw = centerYaw + mCirclesDegreeSep * margin;        float topRoll = centerRoll + mCirclesDegreeSep * -margin;        float bottomRoll = centerRoll + mCirclesDegreeSep * margin;        mAlignmentCircles = new AlignmentCircle[mCirclesCount][mCirclesCount];        Bitmap cameraIcon = BitmapFactory.decodeResource(mContext.getResources(),                R.drawable.ic_action_camera);        for (int i = -margin; i <= margin; i++) {            for (int j = -margin; j <= margin; j++) {                float yaw = centerYaw + mCirclesDegreeSep * i;                float roll = centerRoll + mCirclesDegreeSep * j;                mAlignmentCircles[i + margin][j + margin] = new AlignmentCircle(cameraIcon,                        mCirclesDegreeSep, yaw, roll, mBaseLinePaint, mCircleRadius,                        yaw >= leftYaw, roll <= topRoll, yaw <= rightYaw, roll >= bottomRoll,                        getContext());            }        }    }    private void initConstants() {        int thickness = 2; // Thickness of line in dp        mStrokeWidth = dipToPixels(thickness); // Thickness of line in pixels        int radiusDP = 26; // radius in DP        mCircleRadius = dipToPixels(radiusDP); // radius in pixels        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getContext());        mCirclesCount = (int) Math.sqrt(Integer.parseInt(prefs.getString("no_circles",                getContext().getString(R.string.no_circles_default))));        mCirclesDegreeSep = Float.parseFloat(prefs.getString("circles_dist",                getContext().getString(R.string.circles_dist_default)));        float smoothCoeff = Float.parseFloat(prefs.getString("smooth_coeff",                getContext().getString(R.string.smooth_coeff_default)));        mFilter = new float[]{smoothCoeff, 1 - smoothCoeff};    }    /**     * Set up Paint objects for drawing. Instantiating Paint objects is     * expensive so don't do it in onDraw()     */    private void initPaints() {        mBaseLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mUnalignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mAlignedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mTextBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mBaseLinePaint.setColor(baseLineColor);        mUnalignedPaint.setColor(unalignedIndicatorColor);        mAlignedPaint.setColor(alignedIndicatorColor);        mTextBackgroundPaint.setColor(0x60969696);        mTextPaint.setColor(0xC0FFFFFF);        mBaseLinePaint.setStyle(Paint.Style.STROKE);        mUnalignedPaint.setStyle(Paint.Style.STROKE);        mAlignedPaint.setStyle(Paint.Style.STROKE);        mTextBackgroundPaint.setStyle(Paint.Style.FILL);        mBaseLinePaint.setStrokeWidth(mStrokeWidth);        mUnalignedPaint.setStrokeWidth(mStrokeWidth);        mAlignedPaint.setStrokeWidth(mStrokeWidth);        mTextPaint.setTextSize(spToPixels(5));        mTextPaint.setTextAlign(Paint.Align.LEFT);    }    /**     * Initiates the sensor and registers it for the first time     */    private void initSensors() {        mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);        mGravitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);        mMagneticFieldSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);        mRotationVector = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);        registerSensorListener();    }    @Override    public boolean isInEditMode() {        return true;    }    @Override    public void onAccuracyChanged(Sensor sensor, int accuracy) {    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        drawIndicator(canvas);        drawStats(canvas);        if (mCirclesVisible) {            drawBase(canvas);        }    }    @Override    public void onSensorChanged(SensorEvent event) {        if (event.sensor.getType() == Sensor.TYPE_GRAVITY) {            // units in m/s^2            double yAxisGravity = event.values[1];            zDeviceGravity = event.values[2];            // Angle in degrees of device offset from horizontal            horizontalOffset = Math.toDegrees(Math.acos(yAxisGravity / SensorManager.GRAVITY_EARTH)) - 90;            if (horizontalOffset < 0) {                horizontalOffset += 360;            }            float epsilon = 2f;            float horizontal = 0f; // Angle in degrees representing the horizontal            if (horizontalOffset > (360 - epsilon) || horizontalOffset < (horizontal + epsilon)) {                isAligned = true;                if (mEventListener != null) {                    mEventListener.onAligned();                }            } else {                isAligned = false;                if (mEventListener != null) {                    mEventListener.onUnAligned(horizontalOffset);                }            }            invalidate();            return;        }        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {            // mGravityOrientation = event.values;            Log.d(TAG, "Device acceleration: X[" + event.values[0] + "]     Y[" + event.values[1] + "]      Z[" + event.values[2] + "]   Time from last measurement: " + (System.nanoTime() - sysTime));            sysTime = System.nanoTime();            mGravityOrientation[0] = applyFilter(mGravityOrientation[0], event.values[0], mFilter);            mGravityOrientation[1] = applyFilter(mGravityOrientation[1], event.values[1], mFilter);            mGravityOrientation[2] = applyFilter(mGravityOrientation[2], event.values[2], mFilter);        }        if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {            // mGeomagneticOrientation = event.values;            mGeomagneticOrientation[0] = applyFilter(mGeomagneticOrientation[0],                    event.values[0], mFilter);            mGeomagneticOrientation[1] = applyFilter(mGeomagneticOrientation[1],                    event.values[1], mFilter);            mGeomagneticOrientation[2] = applyFilter(mGeomagneticOrientation[2],                    event.values[2], mFilter);        }        if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {            float rotationMatrix[] = new float[9];            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values);            float angle = (float) Math.toDegrees(Math.acos(rotationMatrix[6])); //only from 0 -> 180            if (zDeviceGravity > 0) {                angle = 360 - angle;            }            angle = 180 - angle;            if (angle < 0) {                angle += 360;            }            mHorizonOffset = applyFilter(mHorizonOffset, angle, mFilter);        }        float R[] = new float[9];        float I[] = new float[9];        boolean success = SensorManager.getRotationMatrix(R, I, mGravityOrientation, mGeomagneticOrientation);        if (success) {            float orientation[] = new float[3];            SensorManager.getOrientation(R, orientation);            float angle = (float) Math.toDegrees(orientation[0]);            // Make angle increase in direction opposite to motion for better effect            angle = 360 - ((angle + 360) % 360);            if (mFirstAngleOffNorthReading) {                angleOffNorth = angle;                mFirstAngleOffNorthReading = false;            } else {                // Make the angle continuous to avoid sudden 359 -> 0 transitions                angle += 360 * mRevolutions;                if (Math.abs(angleOffNorth - angle) > 270) {                    if (angleOffNorth > angle) {                        mRevolutions++;                        angle += 360;                    } else {                        mRevolutions--;                        angle -= 360;                    }                }                // Filter noise using a low pass filter                angleOffNorth = applyFilter(angleOffNorth, angle, mFilter);            }            // Redraw the view            invalidate();        }    }    private float applyFilter(float oldVal, float newVal, float[] filter) {        return filter[0] * oldVal + filter[1] * newVal;    }    /**     * An EventListener can be registered with the HorizontalOffsetView so it     * can be notified when the device becomes horizontal, and when it is no     * longer horizontal     */    public interface EventListener {        /**         * Called when the device first becomes horizontal         */        public void onAligned();        /**         * Called when the device first becomes non-horizontal with an argument         * of the device offset in degrees         */        public void onUnAligned(double offset);    }    /**     * Gives this view a new EventListener     */    public void registerEventListener(EventListener listener) {        mEventListener = listener;    }    public void registerSensorListener() {        mSensorManager.registerListener(this, mGravitySensor, SensorManager.SENSOR_DELAY_FASTEST);        mSensorManager.registerListener(this, mMagneticFieldSensor, SensorManager.SENSOR_DELAY_FASTEST);        mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_FASTEST);        mSensorManager.registerListener(this, mRotationVector, SensorManager.SENSOR_DELAY_FASTEST);    }    public void welcomeUser() {        final String inst = getResources().getString(R.string.welcome_user_message);        mInstView.setText(inst);        mTextToSpeech.speak(inst, TextToSpeech.QUEUE_FLUSH, null);    }    public void instructMove() {        final String inst = getResources().getString(R.string.instruct_move_message);        mInstView.setText(inst);        mTextToSpeech.speak(inst, TextToSpeech.QUEUE_FLUSH, null);    }    public void instructCoverCircles(int remaining) {        final String inst =                String.format(getResources().getString(R.string.instruct_cover_circles_message),                        remaining);        mInstView.setText(inst);        mTextToSpeech.speak(inst, TextToSpeech.QUEUE_FLUSH, null);    }    public void pauseTTS() {        mTextToSpeech.stop();    }    public void destroyTTS() {        mTextToSpeech.shutdown();    }    /**     * unregisterSensorListener() needs to be called when the widget is no     * longer in use to prevent leaking the sensor and draining battery life. A     * good idea would be to call it in onPause() of whatever Activity or     * Fragment is hosting this view.     */    public void unregisterSensorListener() {        mSensorManager.unregisterListener(this);    }}